/*
	g3DTZ - a DTZ extraction utility - by guard3
	Don't delete this comment block; respect my work
	main.cpp
*/
#include <zlib.h>
#include <fstream>
#include <iostream>
#include <string>
#include <sstream>
#include <shlwapi.h>
#include <filesystem>
#include <vector>
#include <algorithm>
#include <string.h>
#include <cmath>

//Must always have lcs/vcs and psp/ps2 defined for successful compilation
//They must always be defined BEFORE including custom headers
#define vcs
#define psp

#include "Leeds.h"
#include "HashNames.h"

//I don't seem to be using those. Eh, whatever
#define LCS_PSP_SIZE 0x5A8AAC
#define LCS_PS2_SIZE 0x5B9178
#define VCS_PSP_SIZE 0x6024D0
#define VCS_PS2_SIZE 0x6495D0

const double pi = 4 * atan(1);

void extractPedStats(ResourceImage& _Game, std::string _OutputFilePath)
{
	std::ofstream file(_OutputFilePath);
	if (!file)
	{
		std::cout << _OutputFilePath << "\nCan't write to file.";
		exit(0);
	}
	file << "# Generated by g3DTZ - by guard3\n#\tA\tB\tC\tD\tE\tF\tG\tH\tI\tJ";
	for (int i = 0; i < 42; i++)
	{
		file
			<< "\n" << _Game.pedStats[i]->name
			<< "\t" << _Game.pedStats[i]->fleeDistance
			<< "\t" << _Game.pedStats[i]->headingChangeRate
			<< "\t" << (int)_Game.pedStats[i]->fear
			<< "\t" << (int)_Game.pedStats[i]->temper
			<< "\t" << (int)_Game.pedStats[i]->lawfulness
			<< "\t" << (int)_Game.pedStats[i]->sexiness
			<< "\t" << _Game.pedStats[i]->attackStrength
			<< "\t" << _Game.pedStats[i]->defendWeakness
			<< "\t" << _Game.pedStats[i]->flags;
	}
	file.close();
}

void extractModelInfo(ResourceImage& _Game, int _StartIndex, int _EndIndex, std::string _OutputFilePath)
{
	std::ofstream file(_OutputFilePath);
	if (!file)
	{
		std::cerr << _OutputFilePath << "\nCouldn't write to file.";
		exit(0);
	}

	std::stringstream objs;
	std::stringstream tobj;
	std::stringstream weap;
	std::stringstream hier;
	std::stringstream cars;
	std::stringstream peds;
	std::stringstream _2dfx;

	file << "# Generated by g3DTZ - by guard3\n";

	for (int i = _StartIndex; i <= _EndIndex; i++)
	{
		if (_Game.modelInfos[i] == nullptr) continue;
		BaseModelInfo& modelInfo = *(_Game.modelInfos[i]);

		std::stringstream hash;
		hash << "HASH_" << std::hex << modelInfo.hashName;

		//Deal with 2dfx
		if (modelInfo._2dfxIndex != -1)
		{
			if (_2dfx.str().empty()) _2dfx << "2dfx\n";
			for (int j = modelInfo._2dfxIndex; j < modelInfo._2dfxIndex + modelInfo.num2dfx; j++)
			{
				_2dfx
					<< i << ", "
					<< _Game._2deffects[j].position.x << ", "
					<< _Game._2deffects[j].position.y << ", "
					<< _Game._2deffects[j].position.z << ", "
					<< (int)_Game._2deffects[j].colour.r << ", "
					<< (int)_Game._2deffects[j].colour.g << ", "
					<< (int)_Game._2deffects[j].colour.b << ", "
					<< (int)_Game._2deffects[j].colour.a << ", "
					<< (int)_Game._2deffects[j].type << ", ";
				if (_Game._2deffects[j].type == 0)
				{
					_2dfx
						<< "\"" << _Game._2deffects[j].light.corona->name << "\", "
						<< "\"" << _Game._2deffects[j].light.shadow->name << "\", "
						<< _Game._2deffects[j].light.distance << ", "
						<< _Game._2deffects[j].light.outerRange << ", "
						<< _Game._2deffects[j].light.size << ", "
						<< _Game._2deffects[j].light.innerRange << ", "
						<< (int)_Game._2deffects[j].light.shadowIntensity << ", "
						<< (int)_Game._2deffects[j].light.flash << ", "
						<< (int)_Game._2deffects[j].light.wet << ", "
						<< (int)_Game._2deffects[j].light.flare << ", "
						<< (int)_Game._2deffects[j].light.flags << "\n";
				}
				else if (_Game._2deffects[j].type == 1)
				{
					_2dfx
						<< _Game._2deffects[j].particle.particleType << ", "
						<< _Game._2deffects[j].particle.strength.x << ", "
						<< _Game._2deffects[j].particle.strength.y << ", "
						<< _Game._2deffects[j].particle.strength.z << ", "
						<< _Game._2deffects[j].particle.scale << "\n";
				}
				else if (_Game._2deffects[j].type == 2)
				{
					_2dfx
						<< (int)_Game._2deffects[j].attractor.subtype << ", "
						<< _Game._2deffects[j].attractor.direction.x << ", "
						<< _Game._2deffects[j].attractor.direction.y << ", "
						<< _Game._2deffects[j].attractor.direction.z << ", "
						<< (int)_Game._2deffects[j].attractor.probability << "\n";
				}
				else
				{
					_2dfx
						<< (int)_Game._2deffects[j].pedbehaviour.behaviour << ", "
						<< _Game._2deffects[j].pedbehaviour.direction.x << ", "
						<< _Game._2deffects[j].pedbehaviour.direction.y << ", "
						<< _Game._2deffects[j].pedbehaviour.direction.z << ", "
						<< _Game._2deffects[j].pedbehaviour.rotation.x << ", "
						<< _Game._2deffects[j].pedbehaviour.rotation.y << ", "
						<< _Game._2deffects[j].pedbehaviour.rotation.z << "\n";
				}
			}
		}

		//Deal with actual IDE
		if (modelInfo.type == TYPE_OBJS)
		{
			if (objs.str().empty()) objs << "objs\n";
			SimpleModelInfo& info = *(SimpleModelInfo*)&modelInfo;
			objs
				<< i << ", "
				<< (names.find(info.hashName) != names.end() ? names[info.hashName] : hash.str()) << ", "
				<< _Game.texList->items[info.txdIndex].name << ", "
				<< (int)info.numObjects << ", ";
			for (int j = 0; j < info.numObjects; j++) objs << info.drawDistances[j] << ", ";
			objs << processModelInfoFlags(info.flags) << "\n";
		}
		else if (modelInfo.type == TYPE_TOBJ)
		{
			if (tobj.str().empty()) tobj << "tobj\n";
			TimeModelInfo& info = *(TimeModelInfo*)&modelInfo;
			tobj
				<< i << ", "
				<< (names.find(info.hashName) != names.end() ? names[info.hashName] : hash.str()) << ", "
				<< _Game.texList->items[info.txdIndex].name << ", "
				<< (int)info.numObjects << ", ";
			for (int j = 0; j < info.numObjects; j++) tobj << info.drawDistances[j] << ", ";
			tobj
				<< processModelInfoFlags(info.flags) << ", "
				<< info.timeOn << ", "
				<< info.timeOff << "\n";
		}
		else if (modelInfo.type == TYPE_WEAP)
		{
			if (weap.str().empty()) weap << "weap\n";
			WeaponModelInfo& info = *(WeaponModelInfo*)&modelInfo;
			weap
				<< i << ", "
				<< (names.find(info.hashName) != names.end() ? names[info.hashName] : hash.str()) << ", "
				<< _Game.texList->items[info.txdIndex].name << ", "
				<< (info.animBlockIndex == -1 ? "null" : _Game.animManager->animBlocks[info.animBlockIndex].name) << ", "
				<< (int)info.numObjects << ", ";
			for (int j = 0; j < info.numObjects; j++) weap << info.drawDistances[j] << ", ";
			weap << processModelInfoFlags(info.flags) << "\n";
		}
		else if (modelInfo.type == TYPE_HIER)
		{
			if (hier.str().empty()) hier << "hier\n";
			hier
				<< i << ", "
				<< (names.find(modelInfo.hashName) != names.end() ? names[modelInfo.hashName] : hash.str()) << ", "
				<< _Game.texList->items[modelInfo.txdIndex].name << "\n";
		}
		else if (modelInfo.type == TYPE_CARS)
		{
			if (cars.str().empty()) cars << "cars\n";
			VehicleModelInfo& info = *(VehicleModelInfo*)&modelInfo;
			std::stringstream comprules;
			comprules << std::hex << info.compRules;
			cars
				<< i << ", "
				<< (names.find(info.hashName) != names.end() ? names[info.hashName] : hash.str()) << ", "
				<< _Game.texList->items[info.txdIndex].name << ", "
				<< vehicleTypes[info.vehicleType] << ", "
#ifdef lcs
				<< handlingNames_lcs[info.handlingIndex] << ", "
#else
				<< "HANDLING, "
#endif
				<< info.gameName << ", "
				<< (info.animBlockIndex == -1 ? "null" : _Game.animManager->animBlocks[info.animBlockIndex].name) << ", "
				<< (info.vehicleClass == -1 ? "ignore" : vehicleClasses[info.vehicleClass]) << ", "
				<< info.frequency << ", "
				<< (int)info.level << ", "
				<< comprules.str() << ", "
				<< (strcmp(vehicleTypes[info.vehicleType], "bike") == 0 ? info.bikeSteerAngle : info.wheelId) << ", "
				<< info.wheelScale << ", "
#ifdef vcs
				<< info.wheelScaleRear << ", "
#endif
				<< info.normalSplay << "\n";
		}
		else
		{
			if (peds.str().empty()) peds << "peds\n";
			PedModelInfo& info = *(PedModelInfo*)&modelInfo;
			std::stringstream carsCanDriveMask;
			carsCanDriveMask << std::hex << info.carsDriveMask;
			peds
				<< i << ", "
				<< (names.find(info.hashName) != names.end() ? names[info.hashName] : hash.str()) << ", "
				<< _Game.texList->items[modelInfo.txdIndex].name << ", "
				<< pedTypes[info.pedType] << ", "
				<< _Game.pedStats[info.pedStatIndex]->name << ", "
#ifdef lcs
				<< animGroups_lcs[info.animGroup] << ", "
#else
				<< _Game.animManager->assocGroups[info.animGroup].groupname << ", "
#endif
				<< carsCanDriveMask.str() << ", "
				<< (info.animFileIndex == -1 ? "null" : _Game.animManager->animBlocks[info.animFileIndex].name) << ", "
				<< (int)info.radio1 << ", "
				<< (int)info.radio2 << "\n";
		}
	}

	if (!objs.str().empty()) objs << "end\n";
	if (!tobj.str().empty()) tobj << "end\n";
	if (!weap.str().empty()) weap << "end\n";
	if (!hier.str().empty()) hier << "end\n";
	if (!cars.str().empty()) cars << "end\n";
	if (!peds.str().empty()) peds << "end\n";
	if (!_2dfx.str().empty()) _2dfx << "end\n";

	file
		<< peds.str()
		<< cars.str()
		<< objs.str()
		<< weap.str() 
		<< hier.str()
		<< tobj.str()
		<< _2dfx.str();

	file.close();
}

void extractInstance(ResourceImage& _Game, Pool<Entity>& _Entity, std::string _OutputFilePath)
{
	std::ofstream file(_OutputFilePath);
	if (!file)
	{
		std::cerr << _OutputFilePath << "\nCouldn't write to file.";
		exit(0);
	}
	file << "# Generated by g3DTZ - by guard3\ninst\n";
	uint32 hashname;
	for (int i = 0; i < _Entity.size; i++)
	{
		hashname = _Game.modelInfos[_Entity.items[i].modelIndex]->hashName;
		std::stringstream hashname_str;
		hashname_str << "HASH_" << std::hex << hashname;
		file
			<< _Entity.items[i].modelIndex << ", "
			<< (names.find(hashname) == names.end() ? hashname_str.str() : names[hashname]) << ", "
			<< "0, "
			<< _Entity.items[i].matrix[3][0] << ", "
			<< _Entity.items[i].matrix[3][1] << ", "
			<< _Entity.items[i].matrix[3][2] << ", "
			<< "1, 1, 1, ";

		double qx, qy, qz, qw;
		double m00 = _Entity.items[i].matrix[0][0];
		double m10 = _Entity.items[i].matrix[0][1];
		double m20 = _Entity.items[i].matrix[0][2];
		double m01 = _Entity.items[i].matrix[1][0];
		double m11 = _Entity.items[i].matrix[1][1];
		double m21 = _Entity.items[i].matrix[1][2];
		double m02 = _Entity.items[i].matrix[2][0];
		double m12 = _Entity.items[i].matrix[2][1];
		double m22 = _Entity.items[i].matrix[2][2];

		double tr = m00 + m11 + m22;

		if (tr > 0)
		{
			double S = sqrt(tr + 1.0) * 2.0; // S=4*qw 
			qw = S / 4.0;
			qx = (m21 - m12) / S;
			qy = (m02 - m20) / S;
			qz = (m10 - m01) / S;
		}
		else if ( (m00 > m11) && (m00 > m22))
		{
			double S = sqrt(1.0 + m00 - m11 - m22) * 2.0; // S=4*qx 
			qw = (m21 - m12) / S;
			qx = S / 4.0;
			qy = (m01 + m10) / S;
			qz = (m02 + m20) / S;
		}
		else if (m11 > m22)
		{
			double S = sqrt(1.0 + m11 - m00 - m22) * 2.0; // S=4*qy
			qw = (m02 - m20) / S;
			qx = (m01 + m10) / S;
			qy = S / 4.0;
			qz = (m12 + m21) / S;
		}
		else
		{
			double S = sqrt(1.0 + m22 - m00 - m11) * 2.0; // S=4*qz
			qw = (m10 - m01) / S;
			qx = (m02 + m20) / S;
			qy = (m12 + m21) / S;
			qz = S / 4.0;
		}
		file
			<< (qx == 0.0 || qx == -0.0 ? 0 : -qx) << ", "
			<< (qy == 0.0 || qy == -0.0 ? 0 : -qy) << ", "
			<< (qz == 0.0 || qz == -0.0 ? 0 : -qz) << ", "
			<< qw << "\n";
	}
	file << "end\n";
	file.close();
}

void extractAttributeZone(ResourceImage& _Game, std::string _OutputFilePath)
{
	std::ofstream file(_OutputFilePath);
	if (!file)
	{
		std::cerr << _OutputFilePath << "\nCouldn't write to file.";
		exit(0);
	}
	file << "# Generated by g3DTZ - by guard3\ncull\n";

	for (int i = 0; i < _Game.numAttributeZones; i++)
	{
		file
			<< (double)(_Game.attributeZones[i].lowerX + _Game.attributeZones[i].upperX) / 2.0 << ", "
			<< (double)(_Game.attributeZones[i].lowerY + _Game.attributeZones[i].upperY) / 2.0 << ", "
			<< (double)(_Game.attributeZones[i].lowerZ + _Game.attributeZones[i].upperZ) / 2.0 << ", "
			<< _Game.attributeZones[i].lowerX << ", "
			<< _Game.attributeZones[i].lowerY << ", "
			<< _Game.attributeZones[i].lowerZ << ", "
			<< _Game.attributeZones[i].upperX << ", "
			<< _Game.attributeZones[i].upperY << ", "
			<< _Game.attributeZones[i].upperZ << ", "
			<< _Game.attributeZones[i].attribute << ", "
			<< _Game.attributeZones[i].wantedLevelDrop << "\n";
	}

	file << "end\n";
	file.close();
}

void extractWeaponInfo(ResourceImage& _Game, std::string _OutputFolderPath)
{
	for (int a = 0; a < 2; a++)
	{
		std::ofstream file;
		if (a == 0)
		{
			file.open(_OutputFolderPath + "\\weapon.dat");
			if (!file)
			{
				std::cerr << _OutputFolderPath << "\\weapon.dat\nCouldn't write to file.";
				exit(0);
			}
		}
		else
		{
			file.open(_OutputFolderPath + "\\weapon2.dat");
			if (!file)
			{
				std::cerr << _OutputFolderPath << "\\weapon2.dat\nCouldn't write to file.";
				exit(0);
			}
		}
		file << "# Generated by g3DTZ - by guard3\n#\tA\tB\tC\tD\tE\tF\tG\tH\tI\tJ\tK\tL\tM\tN\tP\tR\tS\tT\tU\tV\tW\tX\tY\tZ\ta\tb\n";
		for (
			int i = 0;
#ifdef lcs
			i < 37;
#else
			i < 40;
#endif
			i++)
		{
			std::stringstream flags;
			flags << std::hex << _Game.weaponInfos[0][i].flags;
			file
				<< weaponNames[i] << "\t"
				<< fireTypes[_Game.weaponInfos[0][i].fireType] << "\t"
				<< _Game.weaponInfos[0][i].range << "\t"
				<< _Game.weaponInfos[0][i].firingRate << "\t"
				<< _Game.weaponInfos[0][i].reload << "\t"
				<< _Game.weaponInfos[0][i].amountAmmo << "\t"
				<< _Game.weaponInfos[0][i].damage << "\t"
				<< _Game.weaponInfos[0][i].speed << "\t"
				<< _Game.weaponInfos[0][i].radius << "\t"
				<< _Game.weaponInfos[0][i].lifeSpan << "\t"
				<< _Game.weaponInfos[0][i].spread << "\t"
				<< _Game.weaponInfos[0][i].fireOffset.x << "\t"
				<< _Game.weaponInfos[0][i].fireOffset.y << "\t"
				<< _Game.weaponInfos[0][i].fireOffset.z << "\t"
#ifdef lcs
				<< animGroups_lcs[_Game.weaponInfos[0][i].animIndex] << "\t"
#else
				<< _Game.animManager->assocGroups[_Game.weaponInfos[0][i].animIndex].groupname << "\t"
#endif
				<< (int)((double)_Game.weaponInfos[0][i].anim1.loopStart * 30.0) << "\t"
				<< (int)((double)_Game.weaponInfos[0][i].anim1.loopEnd * 30.0) << "\t"
				<< (int)((double)_Game.weaponInfos[0][i].anim1.weaponFired * 30.0) << "\t"
				<< (int)((double)_Game.weaponInfos[0][i].anim2.loopStart * 30.0) << "\t"
				<< (int)((double)_Game.weaponInfos[0][i].anim2.loopEnd * 30.0) << "\t"
				<< (int)((double)_Game.weaponInfos[0][i].anim2.weaponFired * 30.0) << "\t"
				<< (int)((double)_Game.weaponInfos[0][i].animBreakOut * 30.0) << "\t"
				<< _Game.weaponInfos[0][i].modelIndex << "\t"
				<< _Game.weaponInfos[0][i].modelIndex2 << "\t"
				<< flags.str() << "\t"
				<< _Game.weaponInfos[0][i].slot << "\n";
		}
		file << "ENDWEAPONDATA";
		file.close();
	}
}

void extractCarColourData(ResourceImage& _Game, std::string _OutputFolderPath)
{
	std::ofstream file(_OutputFolderPath + "\\carcols.dat");
	if (!file)
	{
		std::cerr << _OutputFolderPath << "\\carcols.dat\nCouldn't write to file.";
		exit(0);
	}

	//Extract RGB colour pairs
	file << "# Generated by g3DTZ - by guard3\ncol\n";
#ifdef lcs
	for (int i = 0; i < 256; i++)
	{
		if (_Game.colourTable->vehicleColours[i].r == 0 &&
			_Game.colourTable->vehicleColours[i].g == 0 &&
			_Game.colourTable->vehicleColours[i].b == 0 &&
			i > 0
			) break;
		file
			<< (int)_Game.colourTable->vehicleColours[i].r << ","
			<< (int)_Game.colourTable->vehicleColours[i].g << ","
			<< (int)_Game.colourTable->vehicleColours[i].b << "\n";
	}
#else
	for (int i = 0; i < 128; i++)
	{
		if (_Game.RGBTable[1][i].r == 0 &&
			_Game.RGBTable[1][i].g == 0 &&
			_Game.RGBTable[1][i].b == 0 &&
			i != 0
			) break;
		file
			<< (int)_Game.RGBTable[1][i].r << ","
			<< (int)_Game.RGBTable[1][i].g << ","
			<< (int)_Game.RGBTable[1][i].b << "\n";
	}
#endif
	file << "end\ncar\n";
	
	//The vector which will hold up all the main data lines
	std::vector<std::string> lineVector;

	for (int i = 0; i < _Game.numModelInfos; i++)
	{
		if (_Game.modelInfos[i] == nullptr) continue;
		if (_Game.modelInfos[i]->type != TYPE_CARS) continue;
		VehicleModelInfo& info = *(VehicleModelInfo*)_Game.modelInfos[i];
		if (info.numColours == 0) continue;
		std::stringstream currentStream;
		std::string name = names[info.hashName];
		std::transform(name.begin(), name.end(), name.begin(), ::tolower);
		currentStream << name;
		for (int j = 0; j < info.numColours; j++)
		{
			for (int a = 0; a < 2; a++)
#ifdef lcs
				currentStream << (a == 0 ? ", " : ",") << (int)info.colours[a][j];
#else
				currentStream << (a == 0 ? ", " : ",") << (int)info.colours[j][a];
#endif
		}
		currentStream << std::endl;
		lineVector.push_back(currentStream.str());
	}

	//Sort the vector alphabetically
	std::sort(lineVector.begin(), lineVector.end());

	for (int i = 0; i < lineVector.size(); i++) file << lineVector[i];
	file << "end\n";
}

void extractPedColourData(ResourceImage& _Game, std::string _OutputFolderPath)
{
#ifdef vcs
	std::ofstream file(_OutputFolderPath + "\\pedcols.dat");
	if (!file)
	{
		std::cerr << _OutputFolderPath << "\\pedcols.dat\nCouldn't write to file.";
		exit(0);
	}

	//Extract RGB colour pairs
	file << "# Generated by g3DTZ - by guard3\ncol\n";
	for (int i = 0; i < 128; i++)
	{
		if (_Game.RGBTable[0][i].r == 0 &&
			_Game.RGBTable[0][i].g == 0 &&
			_Game.RGBTable[0][i].b == 0 &&
			i > 0) break;
		file
			<< (int)_Game.RGBTable[0][i].r << ","
			<< (int)_Game.RGBTable[0][i].g << ","
			<< (int)_Game.RGBTable[0][i].b << "\n";
	}
	file << "end\nped\n";

	//The vector which will hold up all the main data lines
	std::vector<std::string> lineVector;

	for (int i = 0; i < _Game.numModelInfos; i++)
	{
		if (_Game.modelInfos[i] == nullptr) continue;
		if (_Game.modelInfos[i]->type != TYPE_PEDS) continue;
		PedModelInfo& info = *(PedModelInfo*)_Game.modelInfos[i];
		if (info.numColours == 0) continue;
		std::stringstream currentStream;
		std::string name = names[info.hashName];
		std::transform(name.begin(), name.end(), name.begin(), ::tolower);
		currentStream << name;
		for (int j = 0; j < info.numColours; j++)
			for (int a = 0; a < 4; a++)
				currentStream << (a == 0 ? ", " : ",") << (int)info.colours[j][a];
		currentStream << std::endl;
		lineVector.push_back(currentStream.str());
	}

	//Sort the vector alphabetically
	std::sort(lineVector.begin(), lineVector.end());

	for (int i = 0; i < lineVector.size(); i++) file << lineVector[i];
	file << "end\n";
#endif
}

void extractHandling(ResourceImage& _Game, std::string _OutputFilePath)
{
	std::ofstream file(_OutputFilePath);
	if (!file)
	{
		std::cerr << _OutputFilePath << "\nCouldn't write to file.";
		exit(0);
	}
	//Extract general handling data
#ifdef lcs
	file << "; Generated by g3DTZ - by guard3\n;\tA\tB\tC\tD\tF\tG\tH\tI\tJ\tK\tL\tM\tN\tO\tP\tQ\tR\tS\tT\tU\tV\ta\tb\tc\td\te\tf\tg\tab\tac\tag\tah\tai\n";
	for (int i = 0; i < 81; i++)
	{
		GeneralHandling& handling = _Game.handlingManager->generalHandlings[i];
		std::stringstream flags;
		flags << std::hex << handling.flags;
		std::string flags_str = flags.str();
		std::transform(flags_str.begin(), flags_str.end(), flags_str.begin(), ::toupper);
		file
			<< handlingNames_lcs[handling.handlingIndex] << "\t"
			<< handling.mass << "\t"
			<< handling.turnMass << "\t"
			<< handling.dragMult << "\t"
			<< handling.centreOfMass.x << "\t"
			<< handling.centreOfMass.y << "\t"
			<< handling.centreOfMass.z << "\t"
			<< handling.percentSubmerged_file << "\t"
			<< handling.tractionMultiplier << "\t"
			<< handling.tractionLoss << "\t"
			<< handling.tractionBias << "\t"
			<< (int)handling.transmission.numGears << "\t"
			<< handling.transmission.maxVelocity << "\t"
			<< handling.transmission.engineAcceleration * 12500.0 *(handling.transmission.driveType == '4' ? 2.0 : 1.0) << "\t"
			<< handling.transmission.engineInertia << "\t"
			<< handling.transmission.driveType << "\t"
			<< handling.transmission.engineType << "\t"
			<< handling.brakeDeceleration * 2500.0 << "\t"
			<< handling.brakeBias << "\t"
			<< handling.bABS << "\t"
			<< handling.steeringLock << "\t"
			<< handling.suspensionForceLevel << "\t"
			<< handling.suspensionDampingLevel << "\t"
			<< "unk "
			<< handling.suspensionUpperLimit << "\t"
			<< handling.suspensionLowerLimit << "\t"
			<< handling.suspensionBias << "\t"
			<< handling.suspensionAntiDive << "\t"
			<< handling.seatOffsetDistance << "\t"
			<< handling.mass / 2000.0 * handling.collisionDamageMultiplier << "\t"
			<< handling.monetaryValue << "\t"
			<< flags_str << "\t"
			<< (int)handling.frontLights << "\t"
			<< (int)handling.rearLights << "\n";
	}
#else
	file << "; Generated by g3DTZ - by guard3\n;\tA\tB\tC\tD\tF\tG\tH\tI\tJ\tK\tL\tM\tN\tO\tP\tQ\tR\tS\tT\tU\tV\ta\tb\tc\td\te\tf\tg\tab\tac\taf\tag\tah\tai\n";
	for (int i = 0; i < _Game.numModelInfos; i++)
	{
		if (_Game.modelInfos[i] == nullptr) continue;
		if (_Game.modelInfos[i]->type != TYPE_CARS) continue;
		VehicleModelInfo& info = *(VehicleModelInfo*)_Game.modelInfos[i];
		if (info.generalHandling == nullptr) continue;
		GeneralHandling& handling = *info.generalHandling;

		//Convert flags to uppercase hex
		std::stringstream flags;
		flags << std::hex << handling.modelFlags;
		std::string modelFlags = flags.str();
		flags = std::stringstream("");
		flags << std::hex << handling.handlingFlags;
		std::string handlingFlags = flags.str();
		std::transform(modelFlags.begin(), modelFlags.end(), modelFlags.begin(), ::toupper);
		std::transform(handlingFlags.begin(), handlingFlags.end(), handlingFlags.begin(), ::toupper);

		file
			<< names[info.hashName] << "\t"
			<< handling.mass << "\t"
			<< handling.turnMass << "\t"
			<< handling.dragMult << "\t"
			<< handling.centreOfMass.x << "\t"
			<< handling.centreOfMass.y << "\t"
			<< handling.centreOfMass.z << "\t"
			<< handling.percentSubmerged_file << "\t"
			<< handling.tractionMultiplier << "\t"
			<< handling.tractionLoss << "\t"
			<< handling.tractionBias << "\t"
			<< (int)handling.transmission.numGears << "\t"
			<< handling.maxVelocity_file << "\t"
			<< handling.transmission.engineAcceleration * 12500.0 *(handling.transmission.driveType == '4' ? 2.0 : 1.0) << "\t"
			<< handling.transmission.engineInertia << "\t"
			<< handling.transmission.driveType << "\t"
			<< handling.transmission.engineType << "\t"
			<< handling.brakeDeceleration * 2500.0 << "\t"
			<< handling.brakeBias << "\t"
			<< "unk\t"	//bABS
			<< handling.steeringLock << "\t"
			<< handling.suspensionForceLevel << "\t"
			<< handling.suspensionDampingLevel << "\t"
			<< "unk "
			<< handling.suspensionUpperLimit << "\t"
			<< handling.suspensionLowerLimit << "\t"
			<< handling.suspensionBias << "\t"
			<< handling.suspensionAntiDive << "\t"
			<< handling.seatOffsetDistance << "\t"
			<< handling.mass / 2000.0 * handling.collisionDamageMultiplier << "\t"
			<< handling.monetaryValue << "\t"
			<< modelFlags << "\t"
			<< handlingFlags << "\t"
			<< (int)handling.frontLights << "\t"
			<< (int)handling.rearLights << "\n";
	}
#endif

	//Extract boat handling data
	file << ";\n;\tA\tB\tC\tD\tE\tF\tG\tH\tI\tJ\tK\tL\tM\tN\tO\n";
#ifdef lcs
	for (int i = 0; i < 3; i++)
	{
		BoatHandling& handling = _Game.handlingManager->boatHandlings[i];
		file
			<< "%\t"
			<< handlingNames_lcs[handling.handlingIndex] << "\t"
			<< handling.thrustY << "\t"
			<< handling.thrustZ << "\t"
			<< handling.thrustAppZ << "\t"
			<< handling.aqPlaneForce << "\t"
			<< handling.aqPlaneLimit << "\t"
			<< handling.aqPlaneOffset << "\t"
			<< handling.waveAudioMult << "\t"
			<< handling.moveRes.x << "\t"
			<< handling.moveRes.y << "\t"
			<< handling.moveRes.z << "\t"
			<< handling.turnRes.x << "\t"
			<< handling.turnRes.y << "\t"
			<< handling.turnRes.z << "\t"
			<< handling.behindCamHeight << "\n";
	}
#else
	for (int i = 0; i < _Game.numModelInfos; i++)
	{
		if (_Game.modelInfos[i] == nullptr) continue;
		if (_Game.modelInfos[i]->type != TYPE_CARS) continue;
		VehicleModelInfo& info = *(VehicleModelInfo*)_Game.modelInfos[i];
		if (info.boatHandling == nullptr) continue;
		BoatHandling& handling = *info.boatHandling;
		file
			<< "%\t"
			<< names[info.hashName] << "\t"
			<< handling.thrustY << "\t"
			<< handling.thrustZ << "\t"
			<< handling.thrustAppZ << "\t"
			<< handling.aqPlaneForce << "\t"
			<< handling.aqPlaneLimit << "\t"
			<< handling.aqPlaneOffset << "\t"
			<< handling.waveAudioMult << "\t"
			<< handling.moveRes.x << "\t"
			<< handling.moveRes.y << "\t"
			<< handling.moveRes.z << "\t"
			<< handling.turnRes.x << "\t"
			<< handling.turnRes.y << "\t"
			<< handling.turnRes.z << "\t"
			<< handling.behindCamHeight << "\n";
	}
#endif

	//Extract bike handling data
	file << ";\n;\tA\tB\tC\tD\tE\tF\tG\tH\tI\tJ\tK\tL\tM\tN\tO\tP\n";
#ifdef lcs
	for (int i = 0; i < 7; i++)
	{
		BikeHandling& handling = _Game.handlingManager->bikeHandlings[i];
		file
			<< "!\t"
			<< handlingNames_lcs[handling.handlingIndex] << "\t"
			<< handling.leanFwdCOM << "\t"
			<< handling.leanFwdForce << "\t"
			<< handling.leanBakCOM << "\t"
			<< asin(handling.maxLean) * 180 / pi << "\t"
			<< asin(handling.fullAnimLean / 2500) * 2500 * 180 / pi << "\t"
			<< handling.desLean << "\t"
			<< handling.speedSteer << "\t"
			<< handling.slipSteer << "\t"
			<< handling.noPlayerCOMz << "\t"
			<< asin(handling.wheelieAng) * 180 / pi << "\t"
			<< asin(handling.stoppieAng) * 180 / pi << "\t"
			<< handling.wheelieSteer << "\t"
			<< handling.wheelieStabMult << "\t"
			<< handling.stoppieStabMult << "\n";

	}
#else
	for (int i = 0; i < _Game.numModelInfos; i++)
	{
		if (_Game.modelInfos[i] == nullptr) continue;
		if (_Game.modelInfos[i]->type != TYPE_CARS) continue;
		VehicleModelInfo& info = *(VehicleModelInfo*)_Game.modelInfos[i];
		if (info.bikeHandling == nullptr) continue;
		BikeHandling& handling = *info.bikeHandling;
		file
			<< "!\t"
			<< names[info.hashName] << "\t"
			<< handling.leanFwdCOM << "\t"
			<< handling.leanFwdForce << "\t"
			<< handling.leanBakCOM << "\t"
			<< asin(handling.maxLean) * 180 / pi << "\t"
			<< asin(handling.fullAnimLean / 2500) * 2500 * 180 / pi << "\t"
			<< handling.desLean << "\t"
			<< handling.speedSteer << "\t"
			<< handling.slipSteer << "\t"
			<< handling.noPlayerCOMz << "\t"
			<< asin(handling.wheelieAng) * 180 / pi << "\t"
			<< asin(handling.stoppieAng) * 180 / pi << "\t"
			<< handling.wheelieSteer << "\t"
			<< handling.wheelieStabMult << "\t"
			<< handling.stoppieStabMult << "\n";
	}
#endif

	//Extract plane handling data
	file << ";\n;\tA\tB\tC\tD\tE\tF\tG\tH\tI\tJ\tK\tL\tM\tN\tO\tP\tQ\tR\tS\n";
#ifdef lcs
	for (int i = 0; i < 6; i++)
	{
		PlaneHandling& handling = _Game.handlingManager->planeHandlings[i];
		file
			<< "$\t"
			<< handlingNames_lcs[handling.handlingIndex] << "\t"
			<< handling.thrust << "\t"
			<< handling.thrustFallOff << "\t"
			<< handling.yaw << "\t"
			<< handling.yawStab << "\t"
			<< handling.sideSlip << "\t"
			<< handling.roll << "\t"
			<< handling.rollStab << "\t"
			<< handling.pitch << "\t"
			<< handling.pitchStab << "\t"
			<< handling.formLift << "\t"
			<< handling.attackLift << "\t"
			<< handling.moveRes << "\t"
			<< handling.turnRes.x << "\t"
			<< handling.turnRes.y << "\t"
			<< handling.turnRes.z << "\t"
			<< handling.speedRes.x << "\t"
			<< handling.speedRes.y << "\t"
			<< handling.speedRes.z << "\n";
	}
#else
	for (int i = 0; i < _Game.numModelInfos; i++)
	{
		if (_Game.modelInfos[i] == nullptr) continue;
		if (_Game.modelInfos[i]->type != TYPE_CARS) continue;
		VehicleModelInfo& info = *(VehicleModelInfo*)_Game.modelInfos[i];
		if (info.planeHandling == nullptr) continue;
		PlaneHandling& handling = *info.planeHandling;
		file
			<< "$\t"
			<< names[info.hashName] << "\t"
			<< handling.thrust << "\t"
			<< handling.thrustFallOff << "\t"
			<< handling.yaw << "\t"
			<< handling.yawStab << "\t"
			<< handling.sideSlip << "\t"
			<< handling.roll << "\t"
			<< handling.rollStab << "\t"
			<< handling.pitch << "\t"
			<< handling.pitchStab << "\t"
			<< handling.formLift << "\t"
			<< handling.attackLift << "\t"
			<< handling.moveRes << "\t"
			<< handling.turnRes.x << "\t"
			<< handling.turnRes.y << "\t"
			<< handling.turnRes.z << "\t"
			<< handling.speedRes.x << "\t"
			<< handling.speedRes.y << "\t"
			<< handling.speedRes.z << "\n";
	}
#endif
	file << ";the end";
	file.close();
}

void extractObjectInfo(ResourceImage& _Game, std::string _OutputFilePath)
{
	std::ofstream file(_OutputFilePath);
	if (!file)
	{
		std::cerr << _OutputFilePath << "\nCouldn't write to file.";
		exit(0);
	}
	file << "; Generated by g3DTZ - by guard3\n#\tA\tB\tC\tD\tE\tF\tG\tH\tI\tJ\tK\n";
	for (int i = 0; i < _Game.numModelInfos; i++)
	{
		if (_Game.modelInfos[i] == nullptr) continue;
		if (_Game.modelInfos[i]->objectIndex == -1) continue;
		uint32 hashname = _Game.modelInfos[i]->hashName;
		std::stringstream hash;
		hash << "HASH_" << std::hex << hashname;
		file
			<< (names.find(hashname) == names.end() ? hash.str() : names[hashname]) << "\t"
			<< _Game.objectInfo[_Game.modelInfos[i]->objectIndex].mass << ",\t"
			<< _Game.objectInfo[_Game.modelInfos[i]->objectIndex].turnMass << ",\t"
			<< _Game.objectInfo[_Game.modelInfos[i]->objectIndex].airResistance << ",\t"
			<< _Game.objectInfo[_Game.modelInfos[i]->objectIndex].elasticity << ",\t"
			<< _Game.objectInfo[_Game.modelInfos[i]->objectIndex].mass * 0.8 / _Game.objectInfo[_Game.modelInfos[i]->objectIndex].percentSubmerged << ",\t"
			<< _Game.objectInfo[_Game.modelInfos[i]->objectIndex].uprootLimit << ",\t"
			<< _Game.objectInfo[_Game.modelInfos[i]->objectIndex].collisionDamageMultiplier << ",\t"
			<< (int)_Game.objectInfo[_Game.modelInfos[i]->objectIndex].collisionDamageEffect << ",\t"
			<< (int)_Game.objectInfo[_Game.modelInfos[i]->objectIndex].collisionResponseCases << ",\t"
			<< (int)_Game.objectInfo[_Game.modelInfos[i]->objectIndex].cameraAvoid
#ifdef lcs
			<< std::endl;
#else
			<< ",\t" << (int)_Game.objectInfo[_Game.modelInfos[i]->objectIndex].unk1
			<< ",\t" << (int)_Game.objectInfo[_Game.modelInfos[i]->objectIndex].unk2
			<< std::endl;
#endif
	}
	file << "* ;end of file";
	file.close();
}

void extractParticle(ResourceImage& _Game, std::string _OutputFilePath)
{
	std::ofstream file(_OutputFilePath);
	if (!file)
	{
		std::cerr << _OutputFilePath << "\nCouldn't write to file.";
		exit(0);
	}
#ifdef lcs
	file << "; Generated by g3DTZ - by guard3\n;\tA\tB\tC\tD\tCV\tB2\tC2\tD2\tFT\tE\tF\tG\tH\tI\tGA\tHA\tIA\tGZA\tHZA\tIZA\tGZR\tHZR\tIZR\tJ\tK\tL\tM\tN\tO\tP\tQ\tR\tS\tT\tU\tV\tWX\tWY\tWI\tZ\n";
	for (int i = 0; i < 82; i++)
#else
	file << "; Generated by g3DTZ - by guard3\n;\tA\tB\tC\tD\tCV\tB2\tC2\tD2\tFT\tE\tG\tH\tI\tGA\tHA\tIA\tIZR\tJ\tK\tL\tM\tN\tO\tP\tQ\tR\tS\tT\tU\tV\tWX\tWY\tWI\tZ\n";
	for (int i = 0; i < 90; i++)
#endif
	{
		ParticleManager& particle = _Game.particleManager[i];
		file
			<< particle.name << "\t"
			<< (int)particle.renderColouring.r << "\t"
			<< (int)particle.renderColouring.g << "\t"
			<< (int)particle.renderColouring.b << "\t"
			<< particle.initialColourVariation << "\t"
			<< (int)particle.fadeDestinationColour.r << "\t"
			<< (int)particle.fadeDestinationColour.g << "\t"
			<< (int)particle.fadeDestinationColour.b << "\t"
			<< particle.colourFadeTime << "\t"
			<< particle.defaultInitialRadius << "\t"
#ifdef lcs
			<< particle.expansionRate << "\t"
#endif
			<< particle.initialIntensity_black << "\t"
			<< particle.fadeTime_black << "\t"
			<< particle.fadeAmount_black << "\t"
			<< particle.initialIntensity_alpha << "\t"
			<< particle.fadeTime_alpha << "\t"
			<< particle.fadeAmount_alpha << "\t"
#ifdef lcs
			<< particle.initialAngle << "\t"
			<< particle.angleChangeTime << "\t"
			<< particle.angleChangeAmount << "\t"
			<< particle.initialZRadius << "\t"
			<< particle.zRadiusChangeTime << "\t"
#endif
			<< particle.zRadiusChangeAmount << "\t"
			<< (int)particle.animSpeed << "\t"
			<< (int)particle.startAnimFrame << "\t"
			<< (int)particle.finalAnimFrame << "\t"
			<< particle.rotationSpeed << "\t"
			<< particle.gravitationalAcceleration << "\t"
			<< particle.dragFrictionDecceleration << "\t"
			<< particle.defaultLifeSpan << "\t"
			<< particle.positionRandomError << "\t"
			<< particle.velocityRandomError << "\t"
			<< particle.expansionRateError << "\t"
			<< particle.rotationRateError << "\t"
			<< particle.lifeSpanError << "\t"
			<< particle.trailLengthMultiplier << "\t"
			<< particle.stretchX << "\t"
			<< particle.stretchY << "\t"
			<< particle.windFactor << "\t"
			<< sqrt(particle.createRange) << "\t"
			<< particle.flags << "\n";
	}
	file << ";the end";
	file.close();
}

void extractPedGroups(ResourceImage& _Game, std::string _OutputFilePath)
{
	//TODO: Add comments about locations
	int numPedGroups;
#ifdef lcs
	numPedGroups = 37;
#else
	numPedGroups = 71;
#endif
	std::ofstream file(_OutputFilePath);
	if (!file)
	{
		std::cerr << _OutputFilePath << "\nCouldn't write to file.";
		exit(0);
	}
	file << "# Generated by g3DTZ - by guard3\n";
	for (int i = 0; i < numPedGroups; i++)
	{
		for (int j = 0; j < 16; j++)
			file << names[_Game.modelInfos[_Game.pedGroups[i][j]]->hashName] << (j == 15 ? "" : ",\t");
		if (i != numPedGroups - 1) file << std::endl;
	}
	file.close();
}

void extractSurface(ResourceImage& _Game, std::string _OutputFilePath)
{
	const char* surfaces[] = {
		"Rubber",
		"Hard",
		"Road",
		"Loose",
		"Sand",
		"Wet"
	};
	std::ofstream file(_OutputFilePath);
	if (!file)
	{
		std::cerr << _OutputFilePath << "\nCouldn't write to file.";
		exit(0);
	}
	file << "; Generated by g3DTZ - by guard3\n;\tRubber\tHard\tRoad\tLoose\tSand\tWet\n";
	for (int i = 0; i < 6; i++)
	{
		file << surfaces[i] << "\t";
		for (int j = 0; j <= i; j++)
		{
			 file << _Game.surface[i][j] << (j == i ? "" : "\t");
		}
		if (i != 5) file << std::endl;
	}
	file.close();
}

void extractTimeCycle(ResourceImage& _Game, std::string _OutputFilePath)
{
	const char* weatherNames[] = {
		"SUNNY",
		"CLOUDY",
		"RAINY",
		"FOGGY",
		"EXTRASUNNY",
		"HURRICANE",
		"EXTRACOLOURS",
#ifdef lcs
		"SNOW"
#else
		"ULTRASUNNY"
#endif
	};

	const char* hourNames[] = {
		"Midnight",
		"1AM",
		"2AM",
		"3AM",
		"4AM",
		"5AM",
		"6AM",
		"7AM",
		"8AM",
		"9AM",
		"10AM",
		"11AM",
		"Midday",
		"1PM",
		"2PM",
		"3PM",
		"4PM",
		"5PM",
		"6PM",
		"7PM",
		"8PM",
		"9PM",
		"10PM",
		"11PM",
	};

#if !defined(vcs) || !defined(ps2)
	std::string def = "//\n// Amb\tAmb_Obj\tAmb_bl\tAmb_Obj_bl\tDir\tSky top\tSky bot\tSunCore\tSunCorona\tSunSz\tSprSz\tSprBght\tShdw\tLightShd\tPoleShd\tFarClp\tFogSt\tLightOnGround\tLowCloudsRGB\tTopCloudRGB\tBottomCloudRGB\tBlurRGB\tWaterRGBA\n";
#else
	std::string def = "//\n// Amb\tAmb_Obj\tAmb_bl\tAmb_Obj_bl\tDir\tSky top\tSky bot\tSunCore\tSunCorona\tSunSz\tSprSz\tSprBght\tShdw\tLightShd\tPoleShd\tFarClp\tFogSt\tradInt\tradLim\tLightOnGround\tLowCloudsRGB\tTopCloudRGB\tBottomCloudRGB\tBlurRGB\tWaterRGBA\tblurA\tblurOffset\n";
#endif

	std::ofstream file(_OutputFilePath);
	if (!file)
	{
		std::cerr << _OutputFilePath << "\nCouldn't write to file.";
		exit(0);
	}
	file << "// Generated by g3DTZ - by guard3\n//\n";
	for (int i = 0; i < 8; i++)
	{
		file
			<< "//////////////////////////////////////////////// "
			<< weatherNames[i] << std::endl
			<< def;
		for (int j = 0; j < 24; j++)
		{
			file
				<< (j == 12 ? def + "// " : "// ") << hourNames[j] << std::endl
				<< (int)_Game.timecycle->ambientRed[j][i] << " "
				<< (int)_Game.timecycle->ambientGreen[j][i] << " "
				<< (int)_Game.timecycle->ambientBlue[j][i] << "\t"

				<< (int)_Game.timecycle->ambientRed_Obj[j][i] << " "
				<< (int)_Game.timecycle->ambientGreen_Obj[j][i] << " "
				<< (int)_Game.timecycle->ambientBlue_Obj[j][i] << "\t"

				<< (int)_Game.timecycle->ambientRed_Bl[j][i] << " "
				<< (int)_Game.timecycle->ambientGreen_Bl[j][i] << " "
				<< (int)_Game.timecycle->ambientBlue_Bl[j][i] << "\t"

				<< (int)_Game.timecycle->ambientRed_Obj_Bl[j][i] << " "
				<< (int)_Game.timecycle->ambientGreen_Obj_Bl[j][i] << " "
				<< (int)_Game.timecycle->ambientBlue_Obj_Bl[j][i] << "\t"

				<< (int)_Game.timecycle->directionalRed[j][i] << " "
				<< (int)_Game.timecycle->directionalGreen[j][i] << " "
				<< (int)_Game.timecycle->directionalBlue[j][i] << "\t"

				<< (int)_Game.timecycle->skyTopRed[j][i] << " "
				<< (int)_Game.timecycle->skyTopGreen[j][i] << " "
				<< (int)_Game.timecycle->skyTopBlue[j][i] << "\t"

				<< (int)_Game.timecycle->skyBottomRed[j][i] << " "
				<< (int)_Game.timecycle->skyBottomGreen[j][i] << " "
				<< (int)_Game.timecycle->skyBottomBlue[j][i] << "\t"

				<< (int)_Game.timecycle->sunCoreRed[j][i] << " "
				<< (int)_Game.timecycle->sunCoreGreen[j][i] << " "
				<< (int)_Game.timecycle->sunCoreBlue[j][i] << "\t"

				<< (int)_Game.timecycle->sunCoronaRed[j][i] << " "
				<< (int)_Game.timecycle->sunCoronaGreen[j][i] << " "
				<< (int)_Game.timecycle->sunCoronaBlue[j][i] << "\t"

				<< (double)_Game.timecycle->sunSize[j][i] / 10.0 << "\t"
				<< (double)_Game.timecycle->spriteSize[j][i] / 10.0 << "\t"
				<< (double)_Game.timecycle->spriteBrightness[j][i] / 10.0 << "\t"
				<< (int)_Game.timecycle->shadowStrength[j][i] << "\t"
				<< (int)_Game.timecycle->lightShadowStrength[j][i] << "\t"
				<< (int)_Game.timecycle->poleShadowStrength[j][i] << "\t"
				<< (int)_Game.timecycle->farClip[j][i] << "\t"
				<< (int)_Game.timecycle->fogStart[j][i] << "\t"
#if defined(vcs) && defined(ps2)
				<< (int)_Game.timecycle->radiosityIntensity[j][i] << "\t"
				<< (int)_Game.timecycle->radiosityLimit[j][i] << "\t"
#endif
				<< (double)_Game.timecycle->lightsOnGroundBrightness[j][i] / 10.0 << "\t"

				<< (int)_Game.timecycle->lowCloudsRed[j][i] << " "
				<< (int)_Game.timecycle->lowCloudsGreen[j][i] << " "
				<< (int)_Game.timecycle->lowCloudsBlue[j][i] << "\t"

				<< (int)_Game.timecycle->fluffyCloudsTopRed[j][i] << " "
				<< (int)_Game.timecycle->fluffyCloudsTopGreen[j][i] << " "
				<< (int)_Game.timecycle->fluffyCloudsTopBlue[j][i] << "\t"

				<< (int)_Game.timecycle->fluffyCloudsBottomRed[j][i] << " "
				<< (int)_Game.timecycle->fluffyCloudsBottomGreen[j][i] << " "
				<< (int)_Game.timecycle->fluffyCloudsBottomBlue[j][i] << "\t"

				<< (int)_Game.timecycle->blurRed[j][i] << " "
				<< (int)_Game.timecycle->blurGreen[j][i] << " "
				<< (int)_Game.timecycle->blurBlue[j][i] << "\t"

				<< (int)_Game.timecycle->waterRed[j][i] << " "
				<< (int)_Game.timecycle->waterGreen[j][i] << " "
				<< (int)_Game.timecycle->waterBlue[j][i] << " "
				<< (int)_Game.timecycle->waterAlpha[j][i]
#if !defined(vcs) || !defined(ps2)
				<< std::endl;
#else
				<< "\t"
				<< (int)_Game.timecycle->blurAlpha[j][i] << "\t"
				<< (int)_Game.timecycle->blurOffset[j][i] << "\n";
#endif
		}
	}
	file.close();
}

void extractDir(ResourceImage& _Game, std::string _OutputFilePath)
{
	std::vector<dir> dirVector;
	dir temp;

	//Store all valid mdl references to dirVector
#ifdef lcs
	for (int i = 0; i < 4900; i++)
	{
		if (_Game.streaming->mdlStreamingInfos[i].cdPosn == 0 && _Game.streaming->mdlStreamingInfos[i].cdSize == 0) continue;
		temp.start = _Game.streaming->mdlStreamingInfos[i].cdPosn;
		temp.size = _Game.streaming->mdlStreamingInfos[i].cdSize;
		strcpy_s(temp.name, (std::string(names[_Game.modelInfos[i]->hashName]) + ".mdl").c_str());
#else
	for (int i = 0; i < _Game.streaming->texIdOffset; i++)
	{
		if (_Game.streaming->streamingInfos[i].cdSize == 0) continue;
		temp.start = _Game.streaming->streamingInfos[i].cdPosn;
		temp.size = _Game.streaming->streamingInfos[i].cdSize;
		strcpy_s(temp.name, (std::string(names[_Game.modelInfos[i]->hashName]) + ".mdl").c_str());
#endif
		dirVector.push_back(temp);
	}

	//Store all valid tex references to dirVector
#ifdef lcs
	for (int i = 0; i < 1200; i++)
	{
		if (_Game.streaming->texStreamingInfos[i].cdPosn == 0 && _Game.streaming->texStreamingInfos[i].cdSize == 0) continue;
		temp.start = _Game.streaming->texStreamingInfos[i].cdPosn;
		temp.size = _Game.streaming->texStreamingInfos[i].cdSize;
		strcpy_s(temp.name, (std::string(_Game.texList->items[i].name) + ".chk").c_str());
#else
	for (int i = _Game.streaming->texIdOffset; i < _Game.streaming->colIdOffset; i++)
	{
		if (_Game.streaming->streamingInfos[i].cdSize == 0) continue;
		temp.start = _Game.streaming->streamingInfos[i].cdPosn;
		temp.size = _Game.streaming->streamingInfos[i].cdSize;
		strcpy_s(temp.name, (std::string(_Game.texList->items[i - _Game.streaming->texIdOffset].name) + ".xtx").c_str());
#endif
		dirVector.push_back(temp);
	}

	//Store all valid col references to dirVector
#ifdef lcs
	for (int i = 0; i < 15; i++)
	{
		if (_Game.streaming->colStreamingInfos[i].cdPosn == 0 && _Game.streaming->colStreamingInfos[i].cdSize == 0) continue;
		temp.start = _Game.streaming->colStreamingInfos[i].cdPosn;
		temp.size = _Game.streaming->colStreamingInfos[i].cdSize;
		strcpy_s(temp.name, (std::string(_Game.colPool->items[i].name) + ".col2").c_str());
#else
	for (int i = _Game.streaming->colIdOffset; i < _Game.streaming->anmIdOffset; i++)
	{
		if (_Game.streaming->streamingInfos[i].cdSize == 0) continue;
		temp.start = _Game.streaming->streamingInfos[i].cdPosn;
		temp.size = _Game.streaming->streamingInfos[i].cdSize;
		strcpy_s(temp.name, (std::string(_Game.colPool->items[i - _Game.streaming->colIdOffset].name) + ".col2").c_str());
#endif
		dirVector.push_back(temp);
	}

	//Store all valid anim refereces to dirVector
#ifdef lcs
	for (int i = 0; i < 60; i++)
	{
		if (_Game.streaming->anmStreamingInfos[i].cdPosn == 0 && _Game.streaming->anmStreamingInfos[i].cdSize == 0) continue;
		temp.start = _Game.streaming->anmStreamingInfos[i].cdPosn;
		temp.size = _Game.streaming->anmStreamingInfos[i].cdSize;
		strcpy_s(temp.name, (std::string(_Game.animManager->animBlocks[i].name) + ".anim").c_str());
#else
	for (int i = _Game.streaming->anmIdOffset; i < _Game.streaming->numStreamInfos; i++)
	{
		if (_Game.streaming->streamingInfos[i].cdSize == 0) continue;
		temp.start = _Game.streaming->streamingInfos[i].cdPosn;
		temp.size = _Game.streaming->streamingInfos[i].cdSize;
		strcpy_s(temp.name, (std::string(_Game.animManager->animBlocks[i - _Game.streaming->anmIdOffset].name) + ".anim").c_str());
#endif
		dirVector.push_back(temp);
	}

	//Store all extra mdl references to dirVector
#ifdef lcs
	for (int i = 0; i < _Game.streaming->extraDir->numExtraDirs; i++)
	{
#ifdef ps2
		strcpy_s(_Game.streaming->extraDir->extraObjectDirs[i].name, (std::string(_Game.streaming->extraDir->extraObjectDirs[i].name) + ".mdl").c_str());
#else
		strcpy_s(_Game.streaming->extraDir->extraObjectDirs[i].name, (std::string(_Game.streaming->extraDir->extraObjectDirs[i].name) + ".MDL").c_str());
#endif
		dirVector.push_back(_Game.streaming->extraDir->extraObjectDirs[i]);
	}
#else
	for (int i = 0; i < _Game.streaming->numExtraDirs; i++)
	{
#ifdef ps2
		strcpy_s(_Game.streaming->extraObjectDirs[i].name, (std::string(_Game.streaming->extraObjectDirs[i].name) + ".mdl").c_str());
#else
		strcpy_s(_Game.streaming->extraObjectDirs[i].name, (std::string(_Game.streaming->extraObjectDirs[i].name) + ".MDL").c_str());
#endif
		dirVector.push_back(_Game.streaming->extraObjectDirs[i]);
	}
#endif

	//Sort the dirVector
	struct { bool operator() (dir i, dir j) { return i.start < j.start; } } dirComp;
	std::sort(dirVector.begin(), dirVector.end(), dirComp);

	//Remove garbage characters to prettify the dir - OCD :D
	for (int i = 0; i < dirVector.size(); i++)
	{
		for (int j = 0; j < 24; j++)
		{
			if (dirVector[i].name[j] == '\0')
			{
				for (int a = j + 1; a < 24; a++) dirVector[i].name[a] = '\0';
				break;
			}
		}
	}

	//Write all dir entries to output file
	std::ofstream file(_OutputFilePath, std::ios::binary);
	if (!file)
	{
		std::cerr << _OutputFilePath << "\nCouldn't write to file.";
		exit(0);
	}
	for (int i = 0; i < dirVector.size(); i++) file.write(reinterpret_cast<const char*>(&dirVector[i]), sizeof(dir));
	file.close();
}

void extractCutsceneDir(ResourceImage& _Game, std::string _OutputFilePath)
{
	std::ofstream file(_OutputFilePath, std::ios::binary);
	if (!file)
	{
		std::cerr << _OutputFilePath << "\nCouldn't write to file.";
		exit(0);
	}

	for (int i = 0; i < _Game.cutsceneDir->numExtraDirs; i++) file.write(reinterpret_cast<const char*>(&_Game.cutsceneDir->extraObjectDirs[i]), sizeof(dir));

	file.close();
}

void extractSoundData(ResourceImage& _Game, std::string _OutputFolderPath)
{
#ifdef psp
	int sfxSetCounter = 0;
	//std::cout << "SFX" << (sfxSetCounter == 0 ? std::to_string(sfxFileCounter) : std::to_string(sfxSetCounter) + std::to_string(sfxFileCounter)) << "_PSP.SDT\n";
	std::ofstream file;
#ifdef lcs
	for (int i = 0; i < 0x161d; i++)
#else
	for (int i = 0; i < 0x1e63; i++)
#endif
	{
		if (_Game.soundData[i].startingOffset == 0)
		{
			if (i > 0)
			{
				file.close();
			}
			try { std::experimental::filesystem::create_directories(_OutputFolderPath + "\\SET" + std::to_string(sfxSetCounter / 10)); }
			catch (std::exception e) {};
			file.open(_OutputFolderPath + "\\SET" + std::to_string(sfxSetCounter / 10) + "\\SFX" + std::to_string(sfxSetCounter) + "_PSP.SDT", std::ios::binary);
			if (!file)
			{
				std::cerr << _OutputFolderPath << "\\SFX" << sfxSetCounter << "_PSP.SDT\nCouldn\t write to file.";
				exit(0);
			}
			//std::cout << "SFX" << std::dec << sfxSetCounter << "_PSP.SDT\n";
			sfxSetCounter++;
		}
		file.write(reinterpret_cast<const char*>(&_Game.soundData[i]), sizeof(SoundData));
		//std::cout << i << "\t" << std::hex << _Game.soundData[i].startingOffset << "\t" << _Game.soundData[i].size << std::endl;
	}
	file.close();
#endif
}

int main(int argc, char* argv[])
{
	//Check to have only one argument - that is path to GAME.DTZ
	if (argc == 1)
	{
#if defined(lcs) && defined(psp)
		std::cout << "g3DTZ v1.1 - a GAME.DTZ extraction tool by guard3\nUsage: lcs_psp [path to GAME.DTZ]";
#elif defined(lcs) && defined(ps2)
		std::cout << "g3DTZ v1.1 - a GAME.DTZ extraction tool by guard3\nUsage: lcs_ps2 [path to GAME.DTZ]";
#elif defined(vcs) && defined(psp)
		std::cout << "g3DTZ v1.1 - a GAME.DTZ extraction tool by guard3\nUsage: vcs_psp [path to GAME.DTZ]";
#elif defined(vcs) && defined(ps2)
		std::cout << "g3DTZ v1.1 - a GAME.DTZ extraction tool by guard3\nUsage: vcs_ps2 [path to GAME.DTZ]";
#endif
		exit(0);
	}
	if (argc > 2)
	{
		std::cout << "Too many arguments given.";
		exit(0);
	}

	//Decompressing GAME.DTZ
	std::ifstream dtz(argv[1], std::ios::binary | std::ios::ate);
	if (!dtz)
	{
		std::cerr << argv[1] << "\nCouldn't open file.";
		exit(0);
	}

	uLong inputLen = dtz.tellg();
	dtz.seekg(0);
	char* input = new char[inputLen];
	dtz.read(input, inputLen);
	dtz.close();

	uLongf outputLen = 0x1000000;
	Bytef* output = new Bytef[outputLen];

	int result = uncompress(output, &outputLen, (const Bytef*)input, inputLen);
	delete[] input;
	if (result != 0)
	{
		std::cerr << "Decompression error: " << result;
		delete[] output;
		exit(0);
	}
	
	//Load the header
	RelocChunk& header = *(RelocChunk*)output;

	//Relocating pointers
	header.relocTab = (uint32**)((uint32)header.relocTab + (uint32)output);
	for (int i = 0; i < header.numRelocs; i++)
	{
		header.relocTab[i] = (uint32*)((uint32)(header.relocTab[i]) + (uint32)output);
		*(header.relocTab[i]) += (uint32)output;
	}

	ResourceImage& game = *(ResourceImage*)((uint32)output + sizeof(header));

	/*
	std::map<uint32, const char*> boo = {
	};

	for (int i = 0; i < game.numModelInfos; i++)
	{
		if (game.modelInfos[i] == nullptr) continue;

		uint32& hashname = game.modelInfos[i]->hashName;

		if (boo.find(hashname) != boo.end() && names.find(hashname) == names.end())
		{
			std::cout << boo[hashname] << std::endl;
		}
	}
	*/
	
	//Getting main output path
	PathRemoveExtension(argv[1]);
	try { std::experimental::filesystem::create_directories(argv[1]); }
	catch(std::exception e) {};
	std::string outputPath = argv[1];

//#define test

#ifdef test
	//std::cout << std::hex << game.cutsceneDir - (int)output;
	std::cout << std::hex << (uint32)game.soundData - (uint32)output;

	try { std::experimental::filesystem::create_directories(outputPath + "\\sfx"); }
	catch (std::exception e) {};

	extractSoundData(game, outputPath + "\\sfx");
#else
	//Pedcols
#ifdef vcs
	extractPedColourData(game, outputPath);
#endif
	//GTA3.DIR
#ifdef ps2
	extractDir(game, outputPath + "\\gta3ps2.dir");
#else
	extractDir(game, outputPath + "\\gta3psphr.dir");
#endif
	//CUTS.DIR
#if defined(vcs) && defined(psp)
	extractCutsceneDir(game, outputPath + "\\mocappsp.dir");
#elif defined(vcs) && defined(ps2)
	extractCutsceneDir(game, outputPath + "\\mocapps2.dir");
#else
	extractCutsceneDir(game, outputPath + "\\cuts.dir");
#endif
	//Rest of files
	extractTimeCycle(game, outputPath + "\\timecyc.dat");
	extractSurface(game, outputPath + "\\surface.dat");
	extractPedGroups(game, outputPath + "\\pedgrp.dat");
	extractParticle(game, outputPath + "\\particle.cfg");
	extractObjectInfo(game, outputPath + "\\object.dat");
	extractHandling(game, outputPath + "\\handling.cfg");
	extractCarColourData(game, outputPath);
	extractWeaponInfo(game, outputPath);
	extractPedStats(game, outputPath + "\\pedstats.dat");

	//Extracting IDE
	try { std::experimental::filesystem::create_directories(outputPath + "\\ide"); }
	catch (std::exception e) {};
#ifdef lcs
	extractModelInfo(game, 0, 299, outputPath + "\\ide\\default.ide");
	extractModelInfo(game, 300, 639, outputPath + "\\ide\\generic.ide");
	extractModelInfo(game, 640, 1299, outputPath + "\\ide\\indust.ide");
	extractModelInfo(game, 1300, 1539, outputPath + "\\ide\\indroads.ide");
	extractModelInfo(game, 1540, 2310, outputPath + "\\ide\\commer.ide");
	extractModelInfo(game, 2311, 2438, outputPath + "\\ide\\comroad.ide");
	extractModelInfo(game, 2439, 2554, outputPath + "\\ide\\subroads.ide");
	extractModelInfo(game, 2555, 3245, outputPath + "\\ide\\suburb.ide");
	extractModelInfo(game, 3246, 3400, outputPath + "\\ide\\temppart.ide");
	extractModelInfo(game, 3401, 3550, outputPath + "\\ide\\making.ide");
	extractModelInfo(game, 3551, 3680, outputPath + "\\ide\\fortstaunton.ide");
	extractModelInfo(game, 3681, 3745, outputPath + "\\ide\\fortdestroyed.ide");
	extractModelInfo(game, 3746, 3910, outputPath + "\\ide\\leedsbits.ide");
	extractModelInfo(game, 3911, game.numModelInfos - 1, outputPath + "\\ide\\leedsbits2.ide");
#else
	//Not original, but they are nicely split up so that they help cracking hashnames a bit
	extractModelInfo(game, 0, 395, outputPath + "\\ide\\default.ide");
	extractModelInfo(game, 396, 750, outputPath + "\\ide\\generic.ide");
	extractModelInfo(game, 751, 1000, outputPath + "\\ide\\docks.ide");
	extractModelInfo(game, 1001, 1400, outputPath + "\\ide\\airport.ide");
	extractModelInfo(game, 1401, 1650, outputPath + "\\ide\\airport2.ide");
	extractModelInfo(game, 1651, 2000, outputPath + "\\ide\\littleha.ide");
	extractModelInfo(game, 2001, 2250, outputPath + "\\ide\\haiti.ide");
	extractModelInfo(game, 2251, 2500, outputPath + "\\ide\\haiti2.ide");
	extractModelInfo(game, 2501, 2750, outputPath + "\\ide\\downtown.ide");
	extractModelInfo(game, 2751, 3080, outputPath + "\\ide\\downtown2.ide");
	extractModelInfo(game, 3081, 3250, outputPath + "\\ide\\golf.ide");
	extractModelInfo(game, 3251, 3400, outputPath + "\\ide\\cisland.ide");
	extractModelInfo(game, 3401, 3700, outputPath + "\\ide\\starisl.ide");
	extractModelInfo(game, 3701, 3900, outputPath + "\\ide\\islandsf.ide");
	extractModelInfo(game, 3901, 3960, outputPath + "\\ide\\bridge.ide");
	extractModelInfo(game, 3961, 4300, outputPath + "\\ide\\washington.ide");
	extractModelInfo(game, 4301, 4500, outputPath + "\\ide\\oceandrv.ide");
	extractModelInfo(game, 4501, 5000, outputPath + "\\ide\\washington2.ide");
	extractModelInfo(game, 5001, 5200, outputPath + "\\ide\\oceandrv2.ide");
	extractModelInfo(game, 5201, 5600, outputPath + "\\ide\\nbeach.ide");
	extractModelInfo(game, 5601, 5900, outputPath + "\\ide\\nbeach2.ide");
	extractModelInfo(game, 5901, 6200, outputPath + "\\ide\\nbeach3.ide");
	extractModelInfo(game, 6201, 6650, outputPath + "\\ide\\something.ide");
	extractModelInfo(game, 6651, 7200, outputPath + "\\ide\\something2.ide");
	extractModelInfo(game, 7201, 7600, outputPath + "\\ide\\something3.ide");
	extractModelInfo(game, 7601, 7780, outputPath + "\\ide\\something4.ide");
	extractModelInfo(game, 7781, game.numModelInfos - 1, outputPath + "\\ide\\mall.ide");
#endif

	//Extracting IPL
	try { std::experimental::filesystem::create_directories(outputPath + "\\ipl"); }
	catch (std::exception e) {};
	extractInstance(game, *game.buildingPool, outputPath + "\\ipl\\Buildings.ipl");
#ifdef lcs
	extractInstance(game, *game.treadablePool, outputPath + "\\ipl\\Treadables.ipl");
#endif
	extractInstance(game, *game.dummyPool, outputPath + "\\ipl\\Dummys.ipl");
	extractAttributeZone(game, outputPath + "\\ipl\\cull.ipl");

	//Extracting SDTs (PSP only)
#ifdef psp
	try { std::experimental::filesystem::create_directories(outputPath + "\\sfx"); }
	catch (std::exception e) {};
	extractSoundData(game, outputPath + "\\sfx");
#endif
#endif
	delete[] output;
	return 0;
}